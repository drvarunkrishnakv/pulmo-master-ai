/**
 * Exam Notification Service
 * 
 * Monitors NEET-SS (NBE) and INI-SS (AIIMS) exam updates.
 * Phase 2: Reads from Firestore (populated by Cloud Function)
 * Falls back to client-side scraping if Firestore unavailable
 */

import { db } from './firebase';
import { doc, getDoc } from 'firebase/firestore';

const EXAM_NOTIFICATION_KEY = 'pulmo_exam_notifications';
const EXAM_READ_IDS_KEY = 'pulmo_exam_read_ids'; // Separate key for read IDs
const CORS_PROXY = 'https://api.allorigins.win/raw?url=';
const MANUAL_CHECK_URL = 'https://asia-south1-pulmo-master.cloudfunctions.net/manualCheckExamUpdates';
// Primary data source: Static file generated by GitHub Action
const GITHUB_DATA_URL = 'https://raw.githubusercontent.com/drvarunkrishnakv/pulmo-master-ai/main/public/data/exam_notifications.json';

// URLs to monitor
const EXAM_SOURCES = {
    NEET_SS: 'https://natboard.edu.in/viewnbeexam?exam=neetss',
    INI_SS: 'https://www.aiimsexams.ac.in/landingpage/notice'
};

export interface ExamNotification {
    id: string;
    examType: 'NEET-SS' | 'INI-SS';
    title: string;
    year: string;
    links: {
        informationBulletin?: string;
        applicationLink?: string;
        results?: string;
        official: string;
    };
    detectedAt: number;
    isRead: boolean;
}

interface StoredNotifications {
    notifications: ExamNotification[];
    lastCheckedAt: number;
    lastNBEHash: string;
    lastAIIMSHash: string;
}

/**
 * Get set of read notification IDs (persists across sessions)
 */
const getReadIds = (): Set<string> => {
    try {
        const stored = localStorage.getItem(EXAM_READ_IDS_KEY);
        if (stored) return new Set(JSON.parse(stored));
    } catch (e) {
        console.error('Error reading read IDs:', e);
    }
    return new Set();
};

/**
 * Save read notification IDs
 */
const saveReadIds = (ids: Set<string>): void => {
    localStorage.setItem(EXAM_READ_IDS_KEY, JSON.stringify([...ids]));
};

/**
 * Get stored notification data
 */
const getStoredData = (): StoredNotifications => {
    try {
        const stored = localStorage.getItem(EXAM_NOTIFICATION_KEY);
        if (stored) return JSON.parse(stored);
    } catch (e) {
        console.error('Error reading exam notifications:', e);
    }
    return {
        notifications: [],
        lastCheckedAt: 0,
        lastNBEHash: '',
        lastAIIMSHash: ''
    };
};

/**
 * Save notification data
 */
const saveStoredData = (data: StoredNotifications): void => {
    localStorage.setItem(EXAM_NOTIFICATION_KEY, JSON.stringify(data));
};

/**
 * Simple hash function for detecting changes
 */
const simpleHash = (str: string): string => {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
    }
    return hash.toString(36);
};

/**
 * Check Firestore for cloud-scraped notifications (Phase 2)
 */
const checkFirestoreNotifications = async (): Promise<ExamNotification[]> => {
    try {
        console.log('Checking Firestore for exam notifications...');
        const docRef = doc(db, 'exam_notifications', 'latest');
        const snapshot = await getDoc(docRef);

        if (!snapshot.exists()) {
            console.log('No Firestore notifications found');
            return [];
        }

        const data = snapshot.data();
        const notifications: ExamNotification[] = [];
        const readIds = getReadIds();

        // Extract NEET-SS notification
        if (data?.neet_ss) {
            const id = data.neet_ss.id || 'neetss-cloud';
            notifications.push({
                ...data.neet_ss,
                id,
                isRead: readIds.has(id),
                detectedAt: data.neet_ss.detectedAt || Date.now()
            });
        }

        // Extract INI-SS notification
        if (data?.ini_ss) {
            const id = data.ini_ss.id || 'iniss-cloud';
            notifications.push({
                ...data.ini_ss,
                id,
                isRead: readIds.has(id),
                detectedAt: data.ini_ss.detectedAt || Date.now()
            });
        }

        console.log(`Found ${notifications.length} notifications from Firestore`);
        return notifications;
    } catch (e) {
        console.error('Firestore check failed:', e);
        return [];
    }
};

/**
 * Parse NBE NEET-SS page for latest exam info (fallback)
 */
const parseNBEPage = (html: string): ExamNotification | null => {
    try {
        const currentYear = new Date().getFullYear();
        const years = [currentYear + 1, currentYear, currentYear - 1];
        const readIds = getReadIds();

        for (const year of years) {
            const yearPattern = new RegExp(`## ${year}[\\s\\S]*?(?=## \\d{4}|$)`, 'i');
            const match = html.match(yearPattern);

            if (match) {
                const section = match[0];
                const bulletinMatch = section.match(/\[Information Bulletin\]\((.*?)\)/i);
                const applicationMatch = section.match(/\[Application Link\]\((.*?)\)/i);
                const resultsMatch = section.match(/\[Results\]\((.*?)\)/i);

                if (bulletinMatch || applicationMatch) {
                    const id = `neetss-${year}`;
                    return {
                        id,
                        examType: 'NEET-SS',
                        title: `NEET-SS ${year} Updates Available`,
                        year: year.toString(),
                        links: {
                            informationBulletin: bulletinMatch?.[1],
                            applicationLink: applicationMatch?.[1],
                            results: resultsMatch?.[1],
                            official: EXAM_SOURCES.NEET_SS
                        },
                        detectedAt: Date.now(),
                        isRead: readIds.has(id)
                    };
                }
            }
        }
    } catch (e) {
        console.error('Error parsing NBE page:', e);
    }
    return null;
};

/**
 * Fetch page content via CORS proxy (fallback)
 */
const fetchWithProxy = async (url: string): Promise<string | null> => {
    try {
        const response = await fetch(CORS_PROXY + encodeURIComponent(url), {
            headers: { 'Accept': 'text/html' }
        });
        if (!response.ok) return null;
        return await response.text();
    } catch (e) {
        console.error('Error fetching:', url, e);
        return null;
    }
};

/**
 * Client-side scraping fallback
 */
const clientSideScrape = async (data: StoredNotifications): Promise<ExamNotification[]> => {
    const newNotifications: ExamNotification[] = [];

    try {
        const nbeHtml = await fetchWithProxy(EXAM_SOURCES.NEET_SS);
        if (nbeHtml) {
            const newHash = simpleHash(nbeHtml);
            if (newHash !== data.lastNBEHash) {
                const notification = parseNBEPage(nbeHtml);
                if (notification) {
                    newNotifications.push(notification);
                }
                data.lastNBEHash = newHash;
            }
        }
    } catch (e) {
        console.error('Client-side NBE check failed:', e);
    }

    return newNotifications;
};

/**
 * Check for new exam notifications
 * Tries Firestore first, falls back to client-side scraping
 */
export const checkForExamUpdates = async (): Promise<ExamNotification[]> => {
    const data = getStoredData();

    // Throttle: Only check once per hour
    const oneHour = 60 * 60 * 1000;
    if (Date.now() - data.lastCheckedAt < oneHour) {
        console.log('Exam check throttled, returning cached data');
        // Return cached notifications but check read status
        const readIds = getReadIds();
        return data.notifications
            .map(n => ({ ...n, isRead: readIds.has(n.id) }))
            .filter(n => !n.isRead);
    }

    let notifications: ExamNotification[] = [];


    // 1. Try Git-Scraper Static File
    try {
        console.log('Fetching static exam data...');
        const response = await fetch(`${GITHUB_DATA_URL}?t=${Date.now()}`);
        if (response.ok) {
            const json = await response.json();
            if (json.notifications && Array.isArray(json.notifications)) {
                console.log('Static data loaded:', json.notifications.length);
                notifications = json.notifications;
            }
        }
    } catch (e) {
        console.warn('Static file fetch failed, trying fallbacks', e);
    }

    // 2. Fallback to Firestore (if static file failed/empty)
    if (notifications.length === 0) {
        try {
            const firestoreNotifications = await checkFirestoreNotifications();
            if (firestoreNotifications.length > 0) {
                notifications = firestoreNotifications;
            }
        } catch (e) {
            console.log('Firestore unavailable, using client-side fallback');
        }
    }

    // Fallback to client-side scraping if no Firestore results
    if (notifications.length === 0) {
        notifications = await clientSideScrape(data);
    }

    // Save notifications
    data.notifications = notifications.slice(0, 20); // Keep last 20
    data.lastCheckedAt = Date.now();
    saveStoredData(data);

    // Return only unread
    return notifications.filter(n => !n.isRead);
};

/**
 * Get all notifications (read and unread)
 */
export const getAllExamNotifications = (): ExamNotification[] => {
    const readIds = getReadIds();
    return getStoredData().notifications.map(n => ({
        ...n,
        isRead: readIds.has(n.id)
    }));
};

/**
 * Get unread notification count
 */
export const getUnreadCount = (): number => {
    const readIds = getReadIds();
    return getStoredData().notifications.filter(n => !readIds.has(n.id)).length;
};

/**
 * Mark notification as read (persists!)
 */
export const markAsRead = (notificationId: string): void => {
    const readIds = getReadIds();
    readIds.add(notificationId);
    saveReadIds(readIds);
};

/**
 * Mark all notifications as read (persists!)
 */
export const markAllAsRead = (): void => {
    const data = getStoredData();
    const readIds = getReadIds();
    data.notifications.forEach(n => readIds.add(n.id));
    saveReadIds(readIds);
};

/**
 * Force check (bypasses throttle) and triggers Cloud Function scrape
 */
export const forceCheckForUpdates = async (): Promise<ExamNotification[]> => {
    const data = getStoredData();
    data.lastCheckedAt = 0; // Reset throttle
    saveStoredData(data);

    // 1. Try Git-Scraper Static File (Fresh fetch)
    try {
        console.log('Fetching static exam data (Manual)...');
        const response = await fetch(`${GITHUB_DATA_URL}?t=${Date.now()}`); // Cache bust
        if (response.ok) {
            const json = await response.json();
            if (json.notifications && Array.isArray(json.notifications)) {
                console.log('Static data loaded (Manual):', json.notifications.length);

                // Update local storage
                data.notifications = json.notifications;
                data.lastCheckedAt = Date.now();
                saveStoredData(data);

                const readIds = getReadIds();
                return json.notifications.filter((n: ExamNotification) => !readIds.has(n.id));
            }
        }
    } catch (e) {
        console.warn('Manual static fetch failed, trying Cloud Function', e);
    }

    // 2. Fallback to Cloud Function (Legacy)
    try {
        console.log('Triggering manual scrape via Cloud Function (HTTP)...');
        const response = await fetch(MANUAL_CHECK_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        });
        const result = await response.json();

        if (result.success && result.notifications) {
            console.log('Cloud scrape successful:', result.notifications);

            // Update local storage with new data
            data.notifications = result.notifications;
            data.lastCheckedAt = Date.now();
            saveStoredData(data);

            // Return unread
            const readIds = getReadIds();
            return result.notifications.filter((n: ExamNotification) => !readIds.has(n.id));
        }
    } catch (e) {
        console.error('Manual cloud check failed, falling back to Firestore/Client:', e);
    }

    return checkForExamUpdates();
};

/**
 * Get direct links to official pages
 */
export const getOfficialLinks = () => ({
    NEET_SS: EXAM_SOURCES.NEET_SS,
    INI_SS: EXAM_SOURCES.INI_SS
});

/**
 * Clear read status (for testing)
 */
export const clearReadStatus = (): void => {
    localStorage.removeItem(EXAM_READ_IDS_KEY);
};

/**
 * Get last checked time (for display)
 */
export const getLastCheckedTime = (): number => {
    return getStoredData().lastCheckedAt;
};
